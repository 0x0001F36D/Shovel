
* DONE rest of basic required primitives
* DONE array and hash primitives
  array, len, hash, keys
* DONE len must work for strings too
* DONE while, for and foreach in the language
  these will be implemented as part of the standard library.
  Implemented as "standard library" code in Shript itself.
* DONE a hasKey primitive.
* DONE cry loudly if a variable or argument
  has the name of a required primitive
* DONE parser errors should show source context, too
* DONE cry loudly if trying to access a hash value
  via '.' uses a non-existing key; return null if the access is made
  via '[]'.
* DONE only catch our errors (improve on the ignore-errors forms in shovel)
* DONE comments :-)
* DONE FN must also record the number of arguments accepted by the callable.
* DONE blocks are expressions :-)
* DONE apostrophes for string quotation
* DONE NEW-FRAME must also have a 'debug' form
  where it takes a list of the names of variable present in the frame,
  not the number of variables.
* DONE when saving the return addresses, also save the position in code
  for the call, so we can build nice stack traces when an exception is
  thrown.
* DONE keep the names of the variables in the environments and
  display them if in case of an exception.
* DONE check the number of arguments for primitives and required primitives
* DONE add a 'panic' primitive that throws an exception.
* DONE tests !
* DONE record file names in source positions
  (so we can show useful line/column information for multiple files).
* DONE serialization and deserialization
** DONE for the bytecode
** DONE for the VM state
** DONE the state should be serialized with:
   - the MD5 of the serialization of the bytecode for the current VM;
   - the MD5 of the serialization of the source for the current VM;
   - the Shovel VM version.

   This way we can make sure that we throw an error if an attempt is
   made to restart a virtual machine with another VM's state (such an
   attempt would most likely result in an error down the road, but
   it's better not to corrupt data and throw an error ASAP).
** DONE the state serialization and the bytecode serialization
   should start with an MD5 hash of the content to make sure that
   the data wasn't messed up;
* DONE maybe the representation of instructions should take up less space
** DONE don't record lines and columns everywhere;
   record only character indices within files and calculate
   line/column on demand; store the file names in a special dummy
   instruction; instruction start/end positions in source code should
   be only deltas from previous start/end positions;
* DONE figure out how interruptible user primitives are written
  they return an extra value, which is one of:
  - :continue or nil, which means keep on going;
  - :nap-and-retry-on-wake-up, go to sleep and retry the primitive call on
    wake-up;
  - :nap, go to sleep and go on from the next instruction after the
    primitive call with the result returned by the primitive call
    (which is pushed on the stack before going to sleep).
* DONE implement interruptible user primitives
* DONE checking of return values for user primitives
  to make sure that they return an instance of a shovel type; tests
  should make sure that required primitives return an instance of a
  shovel type.
* DONE user primitives should handle their exceptions;
* DONE exception raising and handling
  We don't have any, but we'll have non-local exits (document this)
* DONE error checking for arrays (check that indices are in range)
* DONE push and pop for vectors (make them adjustable)
* DONE comparison (== and !=) must work for booleans and when one of the
  operands is guest-null; also do reference comparison for arrays and hashes;
* DONE results of string slice or indexing should be strings
* DONE it should be possible to assign strings of length 1 to string indices
* DONE add 'upper' and 'lower' primitives for strings
* DONE maybe environment frames should have contain information about
  the location where they were introduced? (file and character
  position). This would help when debugging.
* DONE the VM version should be stored before the payload
  for both bytecode and VM state.

  VM versions are backward compatible. This way it is possible to
  check that we're not trying to decode a version n+m state/bytecode
  on code that only knows how to handle version n state/bytecode.
* TODO tests for all the required primitives
* DONE add some reserved keywords
  class, try, catch, throw, block, block_return
* DONE the type for keyword tokens should be changed to 
  :keyword in 'tokenize-identifier' (and I can probably drop 
  'token-is-keyword')
* DONE non local exits
** DONE reserve and parse keyword 'block'
** DONE reserve and parse keyword 'block_return'
** DONE add VM instruction 'BLOCK address'
** DONE add VM instruction 'BLOCK_RETURN'
** DONE add VM instruction 'POP_BLOCK'
** DONE document new instructions in the README
** DONE serialization with named blocks on the stack
** DONE eliminate explicit local exits
** DONE standard library functions for unique block names
** DONE standard library functions for try/catch
* DONE a keyword - 'context' that pushes on the stack
  a hash containing:
  - under key 'stack': the string representation of the current stack trace and 
  - under key 'environment': the string representation of the current environment.
* TODO documentation
** TODO Shript (language, required primitives)
** TODO VM (instructions, state)
** TODO how to use things
*** TODO calling conventions
**** TODO document the fact that user primitives should handle their exceptions;
     When they don't, the error is stored in the
     'user-primitive-error' field of the virtual machine and the
     virtual machine goes to sleep as if :nap-and-retry-on-wake-up had
     been returned by the primitive as a second value.
*** TODO from Common Lisp
