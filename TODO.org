
* DONE rest of basic required primitives
* DONE array and hash primitives
  array, len, hash, keys
* DONE len must work for strings too
* DONE while, for and foreach in the language
  these will be implemented as part of the standard library.
  Implemented as "standard library" code in Shript itself.
* DONE a hasKey primitive.
* DONE cry loudly if a variable or argument
  has the name of a required primitive
* DONE parser errors should show source context, too
* DONE cry loudly if trying to access a hash value
  via '.' uses a non-existing key; return null if the access is made
  via '[]'.
* DONE only catch our errors (improve on the ignore-errors forms in shovel)
* DONE comments :-)
* DONE FN must also record the number of arguments accepted by the callable.
* DONE blocks are expressions :-)
* DONE apostrophes for string quotation
* DONE NEW-FRAME must also have a 'debug' form
  where it takes a list of the names of variable present in the frame,
  not the number of variables.
* DONE when saving the return addresses, also save the position in code
  for the call, so we can build nice stack traces when an exception is
  thrown.
* DONE keep the names of the variables in the environments and 
  display them if in case of an exception.
* DONE check the number of arguments for primitives and required primitives
* DONE add a 'panic' primitive that throws an exception.
* DONE tests !
* DONE record file names in source positions
  (so we can show useful line/column information for multiple files).
* DONE serialization and deserialization
** DONE for the bytecode
** DONE for the VM state
** DONE the state should be serialized with:
   - the MD5 of the serialization of the bytecode for the current VM;
   - the MD5 of the serialization of the source for the current VM;
   - the Shovel VM version.
     
   This way we can make sure that we throw an error if an attempt is
   made to restart a virtual machine with another VM's state (such an
   attempt would most likely result in an error down the road, but
   it's better not to corrupt data and throw an error ASAP).
** DONE the state serialization and the bytecode serialization
   should start with an MD5 hash of the content to make sure that
   the data wasn't messed up;
* DONE maybe the representation of instructions should take up less space
** DONE don't record lines and columns everywhere;
   record only character indices within files and calculate
   line/column on demand; store the file names in a special dummy
   instruction; instruction start/end positions in source code should
   be only deltas from previous start/end positions;
* DONE figure out how interruptible user primitives are written
  they return an extra value, which is one of:
  - :continue or nil, which means keep on going;
  - :nap-and-retry-on-wake-up, go to sleep and retry the primitive call on
    wake-up;
  - :nap, go to sleep and go on from the next instruction after the
    primitive call with the result returned by the primitive call
    (which is pushed on the stack before going to sleep).
* DONE implement interruptible user primitives
* TODO checking of return values for user primitives
  to make sure that they return an instance of a shovel type; tests
  should make sure that required primitives return an instance of a
  shovel type.
** TODO user primitives should handle their exceptions;
   if an exception is thrown out of a user-defined primitive, it is
   swallowed and guest-null is pushed on the stack.
*** TODO document the fact that user primitives should handle their exceptions;
* DONE exception raising and handling
  We don't have any, but we'll have non-local exits (document this)
* DONE error checking for arrays (check that indices are in range)
* DONE push and pop for vectors (make them adjustable)
* DONE comparison (== and !=) must work for booleans and when one of the
  operands is guest-null; also do reference comparison for arrays and hashes; 
* DONE results of string slice or indexing should be strings
* DONE it should be possible to assign strings of length 1 to string indices
* DONE add 'upper' and 'lower' primitives for strings
* TODO maybe environment frames should have contain information about
  the location where they were introduced? (file and character
  position) This would help when debugging.
* DONE the VM version should be stored before the payload
  for both bytecode and VM state.

  VM versions are backward compatible. This way it is possible to
  check that we're not trying to decode a version n+m state/bytecode
  on code that only knows how to handle version n state/bytecode.
* TODO non local exits
** TODO reserve keyword 'block'
   used as in 'block name { ... block ... }'
** TODO reserve keyword 'block_return'
   used as in 'block_return name, return-value'
** TODO add VM instruction 'BLOCK name, address'
   which pushes a 'block' structure made of name and address on the
   stack.
** TODO add VM instruction 'BLOCK_RETURN name'
   which returns to the address associated with BLOCK *name* and
   leaves the top of the stack (before BLOCK_RETURN) as the top of the
   stack after address.
* TODO documentation
** TODO Shript (language, required primitives)
** TODO VM (instructions, state)
** TODO how to use things
*** TODO from Common Lisp

  
