
(in-package #:shovel-compiler)

(defun compile-string-to-instructions (source)
  (let* ((tokens (shovel-compiler-tokenizer:tokenize-string source))
         (parse-tree (shovel-compiler-parser:parse-tokens tokens :source source))
         (instructions (shovel-compiler-code-generator:generate-instructions
                        parse-tree)))
    (include-relevant-source-as-comments source instructions)))

(defun assemble-instructions (instructions)
  (labels ((assemble-pass-1 (instructions)
             (let ((length 0)
                   (labels-hash (make-hash-table)))
               (dolist (instruction instructions)
                 (if (eq :label (instruction-opcode instruction))
                     (setf (gethash (instruction-arguments instruction)
                                    labels-hash) length)
                     (incf length)))
               (values length labels-hash)))
           (assemble-pass-2 (instructions length labels-hash)
             (let ((result (make-array length))
                   (current 0))
               (dolist (instruction instructions)
                 (let ((opcode (instruction-opcode instruction))
                       (args (instruction-arguments instruction)))
                   (case opcode
                     ((:tjump :fjump :jump :fn)
                      (setf (aref result current)
                            (make-instruction :opcode opcode
                                              :arguments (gethash args labels-hash)))
                      (incf current))
                     (:label)
                     (t (setf (aref result current)
                              instruction)
                        (incf current)))))
               result)))
    (multiple-value-bind (length labels-hash)
        (assemble-pass-1 instructions)
      (assemble-pass-2 instructions length labels-hash))))

(defun show-instructions (instructions)
  (dolist (instruction instructions)
    (let ((opcode (instruction-opcode instruction))
          (args (instruction-arguments instruction)))
      (dolist (comment (instruction-comments instruction))
        (format t "~a~%" comment))
      (cond ((eq :label opcode)
             (format t "~a:" args))
            (t (if (consp args)
                   (format t "    ~a ~{~a~^, ~}" opcode args)
                   (if args
                       (format t "    ~a ~a" opcode args)
                       (format t "    ~a" opcode)))))
      (terpri))))

(defun include-relevant-source-as-comments (source instructions)
  (let ((source-lines (split-sequence:split-sequence #\newline source)))
    (dolist (instruction instructions)
      (alexandria:when-let ((start-pos (instruction-start-pos instruction))
                            (end-pos (instruction-end-pos instruction)))
        (setf (instruction-comments instruction)
              (append (instruction-comments instruction)
                      (extract-relevant-source source-lines start-pos end-pos)))))
    instructions))

(defun extract-relevant-source (source-lines start-pos end-pos)
  (let* ((start-line (pos-line start-pos))
         (end-line (pos-line end-pos))
         (add-elipsis (> end-line start-line))
         (first-line (elt source-lines (1- start-line))))
    (list (with-output-to-string (str)
            (format str "    ; line ~5d: ~a" start-line first-line)
            (when add-elipsis
              (format str " [...content snipped...]")))
          (format nil "    ; line ~5d: ~a"
                  start-line
                  (underline (max (pos-column start-pos)
                                  (first-non-blank first-line))
                             (min (length first-line)
                                  (if add-elipsis
                                      (length first-line)
                                      (pos-column end-pos))))))))
